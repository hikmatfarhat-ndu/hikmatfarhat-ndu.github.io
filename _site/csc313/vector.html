<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Hikmat Farhat. Course resourses | Currently contains lecture notes (programming) part of CSC313</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Hikmat Farhat. Course resourses" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Currently contains lecture notes (programming) part of CSC313" />
<meta property="og:description" content="Currently contains lecture notes (programming) part of CSC313" />
<link rel="canonical" href="/csc313/vector.html" />
<meta property="og:url" content="/csc313/vector.html" />
<meta property="og:site_name" content="Hikmat Farhat. Course resourses" />
<script type="application/ld+json">
{"headline":"Hikmat Farhat. Course resourses","@type":"WebPage","url":"/csc313/vector.html","description":"Currently contains lecture notes (programming) part of CSC313","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Hikmat Farhat. Course resourses" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Hikmat Farhat. Course resourses</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/csc313/README.html">Lectures</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/csc325/">hikmatfarhat-ndu.github.io</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    
<p>Many of the data structures that we will be studying and implementing are already implemented in the Standard Template Library (STL). Our strategy is to use and familiarize ourselves with the provided containers and algorithms and then implement them ourselves.</p>
<h1 id="vector-container">Vector container</h1>
<p>A vector is basically a dynamic array. We can add and remove elements from it and it auto resizes itself. Since we would like to store any type of objects in a vector the implementation uses templates to pass any type to the vector. A vector has the all usual syntax of arrays, specifically the indexing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;vector&gt;
int main(){
    //declare a vector of int. creates an empty vector
    std::vector&lt;int &gt; v;
    //declare a vector of strings
    std::vector&lt;std::string &gt; sv;
    //add elements to the end
    v.push_back(1);
    v.push_back(2);
    sv.push_back("one");
    sv.push_back("two");
    //print all elements similar to arrays
    for(int i=0;i&lt;sv.size();++i)
        std::cout&lt;&lt;sv[i]&lt;&lt;",";
    std::cout&lt;&lt;"\n";
    //print all elements using range-based for loop
    for(auto x:v)
        std::cout&lt;&lt;x&lt;&lt; ",";
    std::cout&lt;&lt;"\n";

    
}
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">push_back</code> member function adds an element at the end of the vector. Above we have used two features from c++11: auto and range-based for loops. As you can see we can create a vector of any type (note the syntax). 
<strong>Note</strong>: since the type of an auto variable is inferred by the compiler it cannot be used with <em>uninitialized</em> variables.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto x;//error
auto y=1;//OK
</code></pre></div></div>
<h2 id="automatic-allocation">Automatic allocation</h2>

<p>In a typical use case when we use <code class="language-plaintext highlighter-rouge">push_back</code> we don’t know in advance the size of the data. If memory allocated to the vector is “full” then the vector needs to allocate more space <strong>and</strong> copy the existing data to the new storage space before adding the new values.
Let us look an example using arrays</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //create an array of two elements
        int size = 2;
        int* p = new int[2];
        for (int i = 0; i &lt; 10; ++i) {
            if (i == size) {//array is full
                std::cout &lt;&lt; "copying\n";
                int* old = p;
                p = new int[size + 1];
                for (int j = 0; j &lt; size; ++j)
                    p[j] = old[j];
                size++;
            }
            p[i] = i;

        }
        std::cout &lt;&lt; "------content-------\n";
        for (int i = 0; i &lt; size; ++i)
            std::cout &lt;&lt; p[i] &lt;&lt; ",";
        std::cout &lt;&lt; "\n";
</code></pre></div></div>
<p>It is obvious from the example that there is a lot of copying. In fact if we add <em>n</em> numbers there will be <em>n<sup>2</sup></em> operations. A smarter strategy would be to overallocate. The overallocation is STL implementation dependent. A good rule of thumb, used by the g++ STL, is to double the size every time.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
        //create an array of two elements
        int size = 2;
        int* p = new int[2];
        for (int i = 0; i &lt; 10; ++i) {
            if (i == size) {//array is full
                std::cout &lt;&lt; "copying\n";
                int* old = p;
                p = new int[2*size];
                for (int j = 0; j &lt; size; ++j)
                    p[j] = old[j];
                size*=2;
            }
            p[i] = i;

        }
        std::cout &lt;&lt; "------content-------\n";
        for (int i = 0; i &lt; size; ++i)
            std::cout &lt;&lt; p[i] &lt;&lt; ",";
        std::cout &lt;&lt; "\n";
    }
</code></pre></div></div>
<p>But as you can see in the output, after the 10th element the values are arbitrary. This is because we didn’t differentiate between <strong>size</strong> and <strong>capacity</strong>. This is exactly how a vector handles allocated memory.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {   std::vector&lt;int&gt; v;
         for (int i = 0; i &lt; 100; i++) {
        std::cout &lt;&lt; "i= " &lt;&lt; i &lt;&lt; ", capacity=" &lt;&lt; v.capacity() &lt;&lt; std::endl;
        v.push_back(i);
          }
    }
</code></pre></div></div>
<p>If you run the above you will see the effect of preallocating memory. <strong>Note</strong>: it seems the msc++ uses a different preallocation strategy. From what i see it looks that the size is incremented 50% every time instead of 100%.</p>
<h3 id="iterators">Iterators</h3>
<p>Iterators are generalization of pointers and present a common interface to all STL containers and algorithms. For an array a pointer is sufficient since the elements of an array form a contiguous location in memory. What if the elements are not stored contiguously? Since every container stores the elements differently it implements its own methods to <em>iterate</em> over its elements. This has the added value that the user does not need to know the internal workings of the container in order to be able to use it.
 Given a container <strong>c</strong> and iterator <strong>itr</strong> points at an element stored in <strong>c</strong>. Therefore dereferencing an iterator <strong>(*itr)</strong> will return the element itself. Also iterators can be incremented and decremented like pointers: (itr++) and (itr–). Furthermore, every container <strong>c</strong> has a <strong>begin</strong> and <strong>end()</strong> method. As an example, suppose that we have a container that stores an integer sequence from 0 to n-1 but even numbers first then odd numbers. For example, 0,2,4,6,8,1,3,5,7,9. Below is a code that allow us to iterate over the values in order</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Container {
    int* p, * _begin;
protected:
    int _size;
    int *_end;
public:
    class Iterator {
        int* current;
        int _size;
    public:
        Iterator(int* p,int size) :current(p),_size(size) {}
        Iterator operator++() {
            
            if (*current == _size-1)current = current + 1;
            else if (*current % 2 == 0)
                current = current + _size / 2;
            else
                current = current-_size/2+1;
            return *this;
        }
        int operator *() {
            return *current;
        }
        bool operator!=(const Iterator&amp; rhs) {
            return current != rhs.current;
        }
        
    };
    Container(int size) :_size(size) {
        p = new int[_size];
        _begin = p;
        _end = p + size;
        for (int i = 0; i &lt; _size; ++i) {
            if (i % 2 == 0)
                p[i / 2] = i;
            else
                p[_size / 2 + i / 2] = i;
        }
    }
    Iterator begin() {
        return Iterator(_begin,_size);
    }
    Iterator end() {
        return Iterator(_end,_size);
    }
};

</code></pre></div></div>
<p>so we can print the values in order as follows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Container c(10);
    for (Container::Iterator itr = c.begin(); itr != c.end(); ++itr)
        std::cout &lt;&lt; *itr &lt;&lt; ",";

</code></pre></div></div>
<p>Note the syntax for a dependent type (we could have used auto) because Iterator is a nested class. Similarly to the above we can use iterators with any STL container. In particular with vectors.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
int main(){
  std::vector&lt;std::string&gt; sv;
  sv.push_back("one");
  sv.push_back("two");
  for(auto itr=sv.begin();itr!=sv.end();itr++){
      std::cout&lt;&lt;(*itr)&lt;&lt;std::endl;
  }
}  
</code></pre></div></div>
<p>The auto keyword is useful since otherwise we have to write down the long type of the iterator: (since it is an iterator to container of type <code class="language-plaintext highlighter-rouge">std::vector&lt;std::string&gt;</code>)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;std::string&gt;::iterator itr;
</code></pre></div></div>
<p>vectors can be used similarly to arrays.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;int&gt; iv;
iv.push_back(1);
iv.push_back(2);
for(int i=0;i&lt;iv.size();i++)
  iv[i]=i;
</code></pre></div></div>
<p>Since vectors are required by the c++ standard to use contiguous memory 
it is best to add and remove(as opposed to change) from the end of a vector.
We still can insert and erase elements at arbitrary position using iterators but it is a <em>costly</em> operation.</p>

<h2 id="pre-allocation">Pre allocation</h2>

<p>In what follows we will use a TestClass</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;int nodebug=0&gt;
struct TestClass {
    int _x, _y;
    TestClass(int x = 0, int y = 0) :_x(x), _y(y) {
       if(!nodebug) std::cout &lt;&lt; "ctor\n";

    }
    TestClass(const TestClass&amp; rhs) {
        if(!nodebug)std::cout &lt;&lt; "copy ctor\n";
        _x = rhs._x;
        _y = rhs._y;
    };
    TestClass&amp; operator=(const TestClass&amp; rhs) {
        if(!nodebug)std::cout &lt;&lt; "assignment\n";
        _x = rhs._x;
        _y = rhs._y;
        return *this;
    }
     std::pair&lt;int, int&gt; val() {
        return std::pair&lt;int, int&gt;(_x, _y);
    }
    int&amp; x() {
        return _x;
    }
    int&amp; y() {
        return _y;
    }
    ~TestClass() {
        if(!nodebug)std::cout &lt;&lt; "dtor\n";
    }
};
</code></pre></div></div>
<p>Let us see what happens when we add objects of type TestClass to a vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;TestClass&lt;0&gt;&gt; v;
TestClass a(1,2);
TestClass b(3,4);
v.push_back(a);
v.push_back(b);
</code></pre></div></div>
<p>if we run the above we get the following output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctor
ctor
copy ctor
copy ctor
copy ctor
</code></pre></div></div>

<p>Obviously there are two calls for the constructor for a and b. The method push_back saves a <strong>copy</strong> of the input hence the two calls for the copy constructor. The third call for the copy constructor is because the vector was resized to accommodate b.</p>

<p>Sometimes it is useful to preallocate memory to minimize the number of copy operations when the vector is resized. There are two ways of doing this.</p>
<ol>
  <li>Specifying the size when the vector is created</li>
  <li>Using the vector::reserve method
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 std::vector&lt;TestClass&lt;0&gt;&gt; v(2);
 TestClass a(1, 2);
 TestClass b(3, 4);
 v[0] = a;
 v[1] = b;
 std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
 std::cout &lt;&lt; "----------------\n";

 }
 {
 std::vector&lt;TestClass&lt;0&gt;&gt; v;
 v.reserve(2);
 TestClass a(1, 2);
 TestClass b(3, 4);
 v.push_back(a);
 v.push_back(b);
 std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
 std::cout &lt;&lt; "----------------\n";
 }
</code></pre></div>    </div>
    <p>The output of the above code is</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctor
ctor
ctor
ctor
assignment
assignment
size= 2
----------------
ctor
ctor
copy ctor
copy ctor
size= 2
----------------
</code></pre></div>    </div>
    <p>This is because not only the vector constructor reserves space for two objects but it will also call the default constructor of the object to initialize the reserved space. In this case we use the index operator to change the values. Whereas the member function reserve does not create objects when it reserves space.
Removing elements from the <strong>end</strong> of the vector is done using <code class="language-plaintext highlighter-rouge">pop_back()</code></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 std::vector&lt;TestClass&lt;0&gt;&gt; v;
 v.push_back(TestClass&lt;0&gt;(1, 2));
 v.push_back(TestClass&lt;0&gt;(3, 4));
 std::cout &lt;&lt; v.size() &lt;&lt; std::endl;
 v.pop_back();
 std::cout &lt;&lt; v.size() &lt;&lt; std::endl;

 }
</code></pre></div>    </div>
    <h2 id="insertion-and-deletion">insertion and deletion</h2>
    <p>So far we added and removed elements from the <strong>end</strong> of the vector. We can do the same operations at arbitrary positions using iterators even though if these operations are to be done repeatedly a vector is not the best data structure to use.</p>
    <h3 id="insertion">insertion</h3>
    <p>The code below uses the <em>insert</em> function to add an element between <strong>a</strong> and <strong>b</strong> of the vector.</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
std::vector&lt;TestClass&lt;0&gt;&gt; v;
v.reserve(4);
TestClass&lt;0&gt; a(1,2);
TestClass&lt;0&gt; b(3,4);
TestClass&lt;0&gt; c(5,6);
TestClass&lt;0&gt; d(7,8);
v.push_back(a);
v.push_back(b);
v.push_back(c);

 auto itr=v.insert(v.begin()+1,d);
    for (auto i = v.begin(); i != v.end(); ++i) {
        if (i == itr)std::cout &lt;&lt; "element inserted here: ";
        std::cout &lt;&lt; i-&gt;x() &lt;&lt; "," &lt;&lt; i-&gt;y() &lt;&lt; std::endl;

    }
}

</code></pre></div></div>
<p>If you inspect the output you will see the following happening</p>
<ol>
  <li>ctor is used to create a,b,c,d.</li>
  <li>copy ctor is used to to copy the values of a,b,c to the vector (push_back)</li>
  <li>copy ctor is used to make a copy of d</li>
  <li>copy ctor is used to copy the value of c the 4th place that was reserved in the vector.</li>
  <li>Assignment is used to overwrite the 3rd place by the value of b</li>
  <li>Assignment is used to overwrite the 2nd place by the value of d</li>
</ol>

<p>This means that inserting a value in a vector any place other than the end will cause order of <strong>n</strong> copy/assignments. If such insertions are done often then a vector is not the optimal data structure to use. Note that the return value of insert is an iterator to the element that was inserted.
Similarly, we can erase values from a vector at arbitrary positions</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  {
  std::vector&lt;TestClass&lt;0&gt;&gt; v(5);
  TestClass&lt;0&gt; a(1, 2);
  TestClass&lt;0&gt; b(3, 4);
  v[0] = a;
  v[1] = b;
  std::cout &lt;&lt; "size= " &lt;&lt; v.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; "----------------\n";
  v.erase(v.begin());
  std::cout &lt;&lt; "-------done----\n";
  }


</code></pre></div></div>
<p>Since the deleted element is at the beginning of the vector it also triggers an order of <strong>n</strong> assignments to move values to the left.
Because of that, if you need to remove multiple items meeting a certain criterion, it is better to use the remove/erase idiom. We illustrate with two different ways of removing elements whose <strong>y</strong> value is 2 from a vector. The first, goes through a loop and when it finds an element with y==2 it erases it. Note that erase returns an iterator to the element <strong>after</strong> the erased one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
std::vector&lt;TestClass&lt;0&gt;&gt; v;
v.reserve(4);
TestClass&lt;0&gt; a(1, 2);
TestClass&lt;0&gt; b(3, 4);
TestClass&lt;0&gt; c(5, 2);
TestClass&lt;0&gt; d(5, 6);
v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d);
std::cout &lt;&lt; "---searching--\n";
for (auto itr = v.begin(); itr != v.end();) {
    if (itr-&gt;y() == 2) {
        itr=v.erase(itr);
    }
    else itr++;
}
std::cout &lt;&lt; "----done searching\n";
  }


</code></pre></div></div>
<p>The second, more efficient way is to use the std::remove_if then erase. The function std::remove_if doesn’t actually remove elements, it “moves all elements meeting the criterion towards the end” of the vector and returns an iterator to the first one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{
    std::vector&lt;TestClass&lt;0&gt;&gt; v;
    v.reserve(4);
    TestClass&lt;0&gt; a(1, 2);
    TestClass&lt;0&gt; b(3, 4);
    TestClass&lt;0&gt; c(5, 2);
    TestClass&lt;0&gt; d(5, 6);
    v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d);
    std::cout &lt;&lt; "---searching--\n";
    auto itr=std::remove_if(v.begin(), v.end(), [](auto&amp; t) { return t.y() == 2; });
    v.erase(itr, v.end());
    std::cout &lt;&lt; "----done searching\n";
}


</code></pre></div></div>
<h2 id="extra">Extra</h2>

<p>One of the most useful STL functions is std::transform. It is similar to the map function in functional languages (and Python). It takes</p>
<ol>
  <li>A source range, defined by start and end iterators</li>
  <li>An iterator to the beginning of the destination range. Note it is your responsibility to make sure that the destination range is large enough to fit the input</li>
  <li>A function that takes an element from the input and transforms it to another element which be stored in the destination range. In the example below, we use transform to convert each TestClass element to another with _x and _y swapped.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
   {
    std::vector&lt;TestClass&lt;1&gt;&gt; u;
    u.reserve(4);
    u.emplace_back(1, 2); u.emplace_back(3, 4); u.emplace_back(5, 2); u.emplace_back(5, 6);
    std::vector&lt;TestClass&lt;1&gt;&gt; v;
    v.resize(u.size());
    std::transform(u.begin(), u.end(), v.begin(), [](auto&amp; t) {
        int tmp = t.x();
        t.x() = t.y();
        t.y() = tmp; 
        return t; }
        );
    for (auto&amp; a : v)
        std::cout &lt;&lt; a.x() &lt;&lt; "," &lt;&lt; a.y() &lt;&lt; std::endl;
    }

</code></pre></div></div>
<p>The STL iterators interface allows us to apply many STL algorithms to almost any container. Below is an example of a few of those algorithms.</p>

<h3 id="counting">Counting</h3>

<p>For the purpose of these examples we will use a simple vector of integers. Note we don’t use the reserve function because in that case no element is created and therefore begin==end.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

#include &lt;vector&gt; {
    int n = 20;
    std::random_device e;
    std::uniform_int_distribution&lt;&gt; dist(1, 10);
    std::vector&lt;int&gt; v;
    v.resize(n);
    std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    int m = dist(e);
    std::cout &lt;&lt; "\n The number of " &lt;&lt; m &lt;&lt; " is " &lt;&lt; std::count(v.begin(), v.end(), m);
    }

</code></pre></div></div>
<p>A different version allow us to use a predicate. For example below we count the even numbers in the input as well as print the min and max in the range.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

#include &lt;vector&gt; {
    int n = 20;
    std::random_device e;
    std::uniform_int_distribution&lt;&gt; dist(1, 10);
    std::vector&lt;int&gt; v;
    v.resize(n);
    std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    int m = dist(e);
    std::cout &lt;&lt; "\n The # of evens is "
    &lt;&lt; std::count(v.begin(), v.end(),[](int i) {return i%2==0;});
    std::cout &lt;&lt; "min element is " &lt;&lt; *std::min_element(v.begin(), v.end())&lt;&lt;std::endl;
    std::cout &lt;&lt; "max element is " &lt;&lt; *std::max_element(v.begin(), v.end())&lt;&lt;std::endl;
    }

</code></pre></div></div>
<p>Many of the algorithms we are using require that the destination has enough space to copy elements to it that is why we resize the destination vector before running the algorithm.
There is a convenient back_insert_iterator that automatically calls the push_back method of the container so we don’t need to resize it beforehand.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
    std::vector&lt;int&gt; v;
    std::back_insert_iterator itr(v);
    *itr = 1;
    *itr = 2;
    *itr = 3;
    for (auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ",";
    std::cout &lt;&lt; std::endl;
    }
</code></pre></div></div>
<p>Let us use a back_insert_iterator to filter all even numbers from a container. Note that vector <strong>d</strong> has 0 size and is not resized beforehand because we don’t know how many even numbers there are in the input.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {
        int n = 20;
        std::random_device e;
        std::uniform_int_distribution&lt;&gt; dist(1, 10);
        std::vector&lt;int&gt; v;
        v.resize(n);
        std::generate(v.begin(), v.end(), [&amp;]() {return  dist(e); });
        std::vector&lt;int&gt; d;
        std::copy_if(v.begin(), v.end(), std::back_insert_iterator(d),
            [](int i) { return i % 2 ==0; });
        for(auto&amp; x:d)
            std::cout &lt;&lt; x &lt;&lt; ",";
        std::cout &lt;&lt; std::endl;
    }

</code></pre></div></div>
<!-- ![](step1.png)
![](step2.png)
![](step3.png)
![](step4.png) -->


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Hikmat Farhat. Course resourses</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Hikmat Farhat. Course resourses</li><li><a class="u-email" href="mailto:hfarhat@ndu.edu.lb">hfarhat@ndu.edu.lb</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/hikmatfarhat-ndu"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">hikmatfarhat-ndu</span></a></li><li><a href="https://www.twitter.com/hikmatfarhat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">hikmatfarhat</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Currently contains lecture notes (programming) part of CSC313  </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
